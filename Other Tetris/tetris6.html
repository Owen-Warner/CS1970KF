<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris 6</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            overflow: hidden;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .game-title {
            font-size: 42px;
            font-weight: bold;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
            letter-spacing: 8px;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 140px;
        }

        .board-container {
            position: relative;
        }

        #game-board {
            border: 3px solid #6c5ce7;
            box-shadow: 0 0 30px rgba(108, 92, 231, 0.6), inset 0 0 20px rgba(0, 0, 0, 0.5);
            background: #0a0a15;
            border-radius: 5px;
        }

        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .panel-box {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #6c5ce7;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .panel-box h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
            color: #a29bfe;
        }

        .panel-box .value {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
        }

        .panel-box .value.highlight {
            color: #feca57;
            text-shadow: 0 0 10px rgba(254, 202, 87, 0.5);
        }

        .preview-canvas, .hold-canvas {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            background: #0a0a15;
            border-radius: 5px;
        }

        .next-queue {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .next-queue canvas {
            width: 80px;
            height: 50px;
            margin: 0 auto;
            background: #0a0a15;
            border-radius: 3px;
        }

        .hold-disabled canvas {
            opacity: 0.4;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .progress-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #6c5ce7, #a29bfe);
            transition: width 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 11px;
            text-align: left;
        }

        .stats-grid .label {
            color: #a29bfe;
        }

        .stats-grid .stat-value {
            text-align: right;
            font-weight: bold;
        }

        .controls {
            font-size: 10px;
            line-height: 1.6;
            text-align: left;
        }

        .controls kbd {
            background: #6c5ce7;
            padding: 1px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 9px;
        }

        .combo-display {
            position: absolute;
            right: -120px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #feca57;
            text-shadow: 0 0 20px rgba(254, 202, 87, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-display.show {
            opacity: 1;
            animation: comboPulse 0.5s ease;
        }

        @keyframes comboPulse {
            0% { transform: translateY(-50%) scale(1.5); }
            100% { transform: translateY(-50%) scale(1); }
        }

        .action-display {
            position: absolute;
            left: 50%;
            top: 40%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
            opacity: 0;
            pointer-events: none;
        }

        .action-display.show {
            animation: actionFade 1s ease forwards;
        }

        @keyframes actionFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            border-radius: 5px;
            z-index: 10;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay h2 {
            font-size: 32px;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .overlay p {
            font-size: 14px;
            color: #a29bfe;
        }

        .overlay .score-display {
            font-size: 28px;
            color: #feca57;
        }

        .overlay .high-score {
            font-size: 14px;
            color: #48dbfb;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .overlay button {
            padding: 12px 35px;
            font-size: 16px;
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            border: none;
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .overlay button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(108, 92, 231, 0.8);
        }

        .overlay button.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #6c5ce7;
        }

        .mode-info {
            font-size: 11px;
            color: #888;
            margin-top: -5px;
        }

        .timer-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            font-weight: bold;
            color: #48dbfb;
            text-shadow: 0 0 15px rgba(72, 219, 251, 0.5);
            z-index: 5;
        }

        .timer-display.warning {
            color: #ff6b6b;
            animation: timerPulse 0.5s ease infinite;
        }

        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .sound-toggle:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <button class="sound-toggle" id="sound-toggle">üîä</button>

    <div class="game-wrapper">
        <div class="game-title">TETRIS 6</div>

        <div class="game-container">
            <div class="left-panel">
                <div class="panel-box" id="hold-box">
                    <h3>Hold [E]</h3>
                    <canvas class="hold-canvas" id="hold-piece" width="80" height="80"></canvas>
                </div>

                <div class="panel-box">
                    <h3>Score</h3>
                    <div class="value highlight" id="score">0</div>
                </div>

                <div class="panel-box">
                    <h3>Level</h3>
                    <div class="value" id="level">1</div>
                    <div class="progress-bar">
                        <div class="fill" id="level-progress" style="width: 0%"></div>
                    </div>
                </div>

                <div class="panel-box">
                    <h3>Lines</h3>
                    <div class="value" id="lines">0</div>
                </div>

                <div class="panel-box">
                    <h3>High Score</h3>
                    <div class="value" id="high-score">0</div>
                </div>
            </div>

            <div class="board-container">
                <canvas id="game-board" width="300" height="600"></canvas>
                <canvas id="particles-canvas" width="300" height="600"></canvas>
                <div class="timer-display hidden" id="timer"></div>
                <div class="combo-display" id="combo"></div>
                <div class="action-display" id="action"></div>

                <div id="start-overlay" class="overlay">
                    <h2>TETRIS 6</h2>
                    <p>Choose Game Mode</p>
                    <div class="mode-buttons">
                        <button id="marathon-btn">MARATHON</button>
                        <p class="mode-info">Classic endless mode</p>
                        <button id="sprint-btn" class="secondary">SPRINT</button>
                        <p class="mode-info">Clear 40 lines fastest</p>
                        <button id="ultra-btn" class="secondary">ULTRA</button>
                        <p class="mode-info">Highest score in 2 minutes</p>
                    </div>
                </div>

                <div id="pause-overlay" class="overlay hidden">
                    <h2>PAUSED</h2>
                    <p>Press P to resume</p>
                </div>

                <div id="gameover-overlay" class="overlay hidden">
                    <h2>GAME OVER</h2>
                    <div class="score-display">Score: <span id="final-score">0</span></div>
                    <div class="high-score" id="new-high-score" style="display: none">NEW HIGH SCORE!</div>
                    <button id="restart-btn">Play Again</button>
                </div>

                <div id="complete-overlay" class="overlay hidden">
                    <h2>COMPLETE!</h2>
                    <div class="score-display" id="complete-message">Time: 0:00</div>
                    <div class="high-score" id="complete-high-score"></div>
                    <button id="complete-restart-btn">Play Again</button>
                </div>
            </div>

            <div class="right-panel">
                <div class="panel-box">
                    <h3>Next</h3>
                    <div class="next-queue">
                        <canvas id="next-1" width="80" height="50"></canvas>
                        <canvas id="next-2" width="80" height="50"></canvas>
                        <canvas id="next-3" width="80" height="50"></canvas>
                        <canvas id="next-4" width="80" height="50"></canvas>
                        <canvas id="next-5" width="80" height="50"></canvas>
                    </div>
                </div>

                <div class="panel-box">
                    <h3>Stats</h3>
                    <div class="stats-grid">
                        <span class="label">Tetrises:</span>
                        <span class="stat-value" id="stat-tetrises">0</span>
                        <span class="label">T-Spins:</span>
                        <span class="stat-value" id="stat-tspins">0</span>
                        <span class="label">Combos:</span>
                        <span class="stat-value" id="stat-combos">0</span>
                        <span class="label">B2B:</span>
                        <span class="stat-value" id="stat-b2b">0</span>
                    </div>
                </div>

                <div class="panel-box">
                    <h3>Controls</h3>
                    <div class="controls">
                        <kbd>‚Üê</kbd><kbd>‚Üí</kbd> Move<br>
                        <kbd>‚Üë</kbd> Rotate CW<br>
                        <kbd>Z</kbd> Rotate CCW<br>
                        <kbd>‚Üì</kbd> Soft Drop<br>
                        <kbd>Space</kbd> Hard Drop<br>
                        <kbd>E</kbd> Hold<br>
                        <kbd>P</kbd> Pause
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GAME CONSTANTS =====
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const PREVIEW_BLOCK_SIZE = 15;
        const HOLD_BLOCK_SIZE = 16;

        // ===== TETROMINOES (Including 2 new pieces: Plus and U) =====
        const TETROMINOES = {
            I: {
                shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
                color: '#00f5ff',
                glow: '#00f5ff'
            },
            O: {
                shape: [[1,1], [1,1]],
                color: '#ffeb3b',
                glow: '#ffeb3b'
            },
            T: {
                shape: [[0,1,0], [1,1,1], [0,0,0]],
                color: '#e040fb',
                glow: '#e040fb'
            },
            S: {
                shape: [[0,1,1], [1,1,0], [0,0,0]],
                color: '#76ff03',
                glow: '#76ff03'
            },
            Z: {
                shape: [[1,1,0], [0,1,1], [0,0,0]],
                color: '#ff5252',
                glow: '#ff5252'
            },
            J: {
                shape: [[1,0,0], [1,1,1], [0,0,0]],
                color: '#448aff',
                glow: '#448aff'
            },
            L: {
                shape: [[0,0,1], [1,1,1], [0,0,0]],
                color: '#ff9100',
                glow: '#ff9100'
            },
            // NEW PIECE: Plus/Cross shape
            P: {
                shape: [[0,1,0], [1,1,1], [0,1,0]],
                color: '#ff69b4',
                glow: '#ff69b4'
            },
            // NEW PIECE: U shape
            U: {
                shape: [[1,0,1], [1,1,1], [0,0,0]],
                color: '#40e0d0',
                glow: '#40e0d0'
            }
        };

        const TETROMINO_NAMES = Object.keys(TETROMINOES);

        // SRS Wall Kick Data
        const WALL_KICKS = {
            normal: {
                '0>1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
                '1>0': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
                '1>2': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
                '2>1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
                '2>3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
                '3>2': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
                '3>0': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
                '0>3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]]
            },
            I: {
                '0>1': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
                '1>0': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
                '1>2': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
                '2>1': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
                '2>3': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
                '3>2': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
                '3>0': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
                '0>3': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]]
            }
        };

        // ===== GAME STATE =====
        let board = [];
        let currentPiece = null;
        let holdPiece = null;
        let canHold = true;
        let pieceQueue = [];
        let bag = [];

        let score = 0;
        let level = 1;
        let lines = 0;
        let combo = -1;
        let backToBack = false;

        let gameOver = false;
        let paused = false;
        let gameStarted = false;
        let gameMode = 'marathon';

        let lastTime = 0;
        let dropCounter = 0;
        let lockDelay = 0;
        let lockDelayLimit = 500;
        let lockMoves = 0;
        let lockMovesLimit = 15;

        // DAS (Delayed Auto Shift)
        let dasDelay = 170;
        let dasInterval = 50;
        let dasTimer = 0;
        let dasDirection = 0;
        let dasActive = false;

        // Stats
        let stats = { tetrises: 0, tspins: 0, combos: 0, b2b: 0 };

        // Timer for Sprint/Ultra modes
        let gameTimer = 0;
        let timerInterval = null;

        // Particles
        let particles = [];

        // Sound
        let soundEnabled = true;
        let audioContext = null;

        // High scores
        let highScores = {
            marathon: 0,
            sprint: Infinity,
            ultra: 0
        };

        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const particlesCanvas = document.getElementById('particles-canvas');
        const particlesCtx = particlesCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-piece');
        const holdCtx = holdCanvas.getContext('2d');
        const nextCanvases = [1,2,3,4,5].map(i => ({
            canvas: document.getElementById(`next-${i}`),
            ctx: document.getElementById(`next-${i}`).getContext('2d')
        }));

        // ===== UI ELEMENTS =====
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const linesEl = document.getElementById('lines');
        const highScoreEl = document.getElementById('high-score');
        const levelProgressEl = document.getElementById('level-progress');
        const comboEl = document.getElementById('combo');
        const actionEl = document.getElementById('action');
        const timerEl = document.getElementById('timer');
        const holdBox = document.getElementById('hold-box');

        const startOverlay = document.getElementById('start-overlay');
        const pauseOverlay = document.getElementById('pause-overlay');
        const gameoverOverlay = document.getElementById('gameover-overlay');
        const completeOverlay = document.getElementById('complete-overlay');
        const finalScoreEl = document.getElementById('final-score');
        const newHighScoreEl = document.getElementById('new-high-score');
        const completeMessageEl = document.getElementById('complete-message');
        const completeHighScoreEl = document.getElementById('complete-high-score');

        // ===== SOUND SYSTEM =====
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(freq, duration, type = 'square', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = freq;
            oscillator.type = type;
            gainNode.gain.value = volume;
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playMoveSound() { playSound(200, 0.05); }
        function playRotateSound() { playSound(300, 0.08); }
        function playDropSound() { playSound(150, 0.1); }
        function playLockSound() { playSound(100, 0.15, 'triangle'); }
        function playClearSound(lines) {
            const freq = 400 + lines * 100;
            playSound(freq, 0.2, 'sine', 0.15);
            setTimeout(() => playSound(freq * 1.5, 0.15, 'sine', 0.1), 100);
        }
        function playTetrisSound() {
            [523, 659, 784, 1047].forEach((f, i) => {
                setTimeout(() => playSound(f, 0.2, 'sine', 0.12), i * 80);
            });
        }
        function playGameOverSound() {
            [400, 350, 300, 250].forEach((f, i) => {
                setTimeout(() => playSound(f, 0.3, 'sawtooth', 0.08), i * 150);
            });
        }

        // ===== PARTICLE SYSTEM =====
        function createParticles(row) {
            const y = row * BLOCK_SIZE + BLOCK_SIZE / 2;
            for (let x = 0; x < COLS; x++) {
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: x * BLOCK_SIZE + BLOCK_SIZE / 2,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 3,
                        life: 1,
                        color: `hsl(${Math.random() * 60 + 40}, 100%, 60%)`,
                        size: Math.random() * 4 + 2
                    });
                }
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= dt * 2;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
            particles.forEach(p => {
                particlesCtx.globalAlpha = p.life;
                particlesCtx.fillStyle = p.color;
                particlesCtx.beginPath();
                particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                particlesCtx.fill();
            });
            particlesCtx.globalAlpha = 1;
        }

        // ===== 7-BAG RANDOMIZER =====
        function fillBag() {
            bag = [...TETROMINO_NAMES];
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
        }

        function getNextPiece() {
            if (bag.length === 0) fillBag();
            return bag.pop();
        }

        function fillQueue() {
            while (pieceQueue.length < 6) {
                pieceQueue.push(getNextPiece());
            }
        }

        // ===== BOARD FUNCTIONS =====
        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        }

        function createPiece(type) {
            const tetromino = TETROMINOES[type];
            return {
                type: type,
                shape: tetromino.shape.map(row => [...row]),
                color: tetromino.color,
                glow: tetromino.glow,
                x: Math.floor(COLS / 2) - Math.ceil(tetromino.shape[0].length / 2),
                y: type === 'I' ? -1 : 0,
                rotation: 0
            };
        }

        // ===== COLLISION DETECTION =====
        function hasCollision(piece, offsetX = 0, offsetY = 0, shape = piece.shape) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;

                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        if (newY >= 0 && board[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // ===== ROTATION WITH SRS WALL KICKS =====
        function rotateMatrix(matrix, clockwise = true) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = Array.from({ length: cols }, () => Array(rows).fill(0));

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (clockwise) {
                        rotated[x][rows - 1 - y] = matrix[y][x];
                    } else {
                        rotated[cols - 1 - x][y] = matrix[y][x];
                    }
                }
            }
            return rotated;
        }

        function rotate(clockwise = true) {
            if (currentPiece.type === 'O') return false;

            const rotated = rotateMatrix(currentPiece.shape, clockwise);
            const oldRotation = currentPiece.rotation;
            const newRotation = clockwise
                ? (oldRotation + 1) % 4
                : (oldRotation + 3) % 4;

            const kickKey = `${oldRotation}>${newRotation}`;
            const kicks = currentPiece.type === 'I'
                ? WALL_KICKS.I[kickKey]
                : WALL_KICKS.normal[kickKey];

            for (const [kx, ky] of kicks) {
                if (!hasCollision(currentPiece, kx, -ky, rotated)) {
                    currentPiece.x += kx;
                    currentPiece.y -= ky;
                    currentPiece.shape = rotated;
                    currentPiece.rotation = newRotation;
                    playRotateSound();
                    resetLockDelay();
                    return true;
                }
            }
            return false;
        }

        // ===== T-SPIN DETECTION =====
        function detectTSpin() {
            if (currentPiece.type !== 'T') return false;

            const corners = [
                [0, 0], [2, 0], [0, 2], [2, 2]
            ];

            let filledCorners = 0;
            for (const [cx, cy] of corners) {
                const bx = currentPiece.x + cx;
                const by = currentPiece.y + cy;

                if (bx < 0 || bx >= COLS || by >= ROWS || (by >= 0 && board[by][bx])) {
                    filledCorners++;
                }
            }

            return filledCorners >= 3;
        }

        // ===== PIECE LOCKING =====
        function lockPiece() {
            let isTSpin = detectTSpin();

            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;

                        if (boardY < 0) {
                            endGame();
                            return;
                        }
                        board[boardY][boardX] = currentPiece.color;
                    }
                }
            }

            playLockSound();
            clearLines(isTSpin);
            spawnPiece();
        }

        // ===== LINE CLEARING =====
        function clearLines(isTSpin) {
            let linesCleared = 0;
            let clearedRows = [];

            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== null)) {
                    clearedRows.push(y);
                    linesCleared++;
                }
            }

            if (linesCleared > 0) {
                // Create particles for cleared rows
                clearedRows.forEach(row => createParticles(row));

                // Remove cleared rows
                clearedRows.forEach(row => {
                    board.splice(row, 1);
                    board.unshift(Array(COLS).fill(null));
                });

                playClearSound(linesCleared);

                // Combo system
                combo++;
                if (combo > 0) {
                    stats.combos = Math.max(stats.combos, combo);
                    showCombo(combo);
                }

                // Calculate score
                let points = 0;
                let actionText = '';
                let isDifficult = false;

                if (isTSpin) {
                    stats.tspins++;
                    isDifficult = true;
                    switch (linesCleared) {
                        case 1: points = 800; actionText = 'T-SPIN SINGLE'; break;
                        case 2: points = 1200; actionText = 'T-SPIN DOUBLE'; break;
                        case 3: points = 1600; actionText = 'T-SPIN TRIPLE'; break;
                    }
                } else {
                    switch (linesCleared) {
                        case 1: points = 100; actionText = 'SINGLE'; break;
                        case 2: points = 300; actionText = 'DOUBLE'; break;
                        case 3: points = 500; actionText = 'TRIPLE'; break;
                        case 4:
                            points = 800;
                            actionText = 'TETRIS!';
                            isDifficult = true;
                            stats.tetrises++;
                            playTetrisSound();
                            break;
                    }
                }

                // Back-to-back bonus
                if (isDifficult) {
                    if (backToBack) {
                        points = Math.floor(points * 1.5);
                        actionText = 'B2B ' + actionText;
                        stats.b2b++;
                    }
                    backToBack = true;
                } else {
                    backToBack = false;
                }

                // Combo bonus
                if (combo > 0) {
                    points += 50 * combo * level;
                }

                points *= level;
                score += points;
                lines += linesCleared;

                showAction(actionText);

                // Level up (every 10 lines)
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = Math.min(newLevel, 15);
                }

                // Check Sprint mode completion
                if (gameMode === 'sprint' && lines >= 40) {
                    completeGame();
                }

                updateUI();
            } else {
                combo = -1;
            }
        }

        // ===== SPAWNING =====
        function spawnPiece() {
            fillQueue();
            const type = pieceQueue.shift();
            currentPiece = createPiece(type);
            canHold = true;
            lockDelay = 0;
            lockMoves = 0;

            if (hasCollision(currentPiece)) {
                endGame();
                return;
            }

            drawQueue();
            drawHoldPiece();
        }

        // ===== HOLD PIECE =====
        function hold() {
            if (!canHold) return;

            canHold = false;
            playRotateSound();

            if (holdPiece === null) {
                holdPiece = createPiece(currentPiece.type);
                fillQueue();
                const type = pieceQueue.shift();
                currentPiece = createPiece(type);
            } else {
                const tempType = currentPiece.type;
                currentPiece = createPiece(holdPiece.type);
                holdPiece = createPiece(tempType);
            }

            lockDelay = 0;
            lockMoves = 0;
            drawQueue();
            drawHoldPiece();
        }

        // ===== MOVEMENT =====
        function movePiece(dx, dy) {
            if (!hasCollision(currentPiece, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                if (dx !== 0) playMoveSound();
                if (dy > 0) resetLockDelay();
                else if (dx !== 0) resetLockDelay();
                return true;
            }
            return false;
        }

        function hardDrop() {
            let dropDistance = 0;
            while (!hasCollision(currentPiece, 0, 1)) {
                currentPiece.y++;
                dropDistance++;
            }
            score += dropDistance * 2;
            playDropSound();
            lockPiece();
            updateUI();
        }

        function softDrop() {
            if (movePiece(0, 1)) {
                score += 1;
                updateUI();
                return true;
            }
            return false;
        }

        // ===== LOCK DELAY =====
        function resetLockDelay() {
            if (hasCollision(currentPiece, 0, 1)) {
                lockMoves++;
                if (lockMoves < lockMovesLimit) {
                    lockDelay = 0;
                }
            }
        }

        // ===== DRAWING =====
        function drawBlock(ctx, x, y, color, size, glow = null) {
            // Main block
            ctx.fillStyle = color;
            ctx.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);

            // Highlight (top-left)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillRect(x * size + 1, y * size + 1, size - 2, 3);
            ctx.fillRect(x * size + 1, y * size + 1, 3, size - 2);

            // Shadow (bottom-right)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x * size + 1, y * size + size - 4, size - 2, 3);
            ctx.fillRect(x * size + size - 4, y * size + 1, 3, size - 2);

            // Glow effect
            if (glow) {
                ctx.shadowColor = glow;
                ctx.shadowBlur = 8;
                ctx.strokeStyle = glow;
                ctx.lineWidth = 1;
                ctx.strokeRect(x * size + 1, y * size + 1, size - 2, size - 2);
                ctx.shadowBlur = 0;
            }
        }

        function drawGhostPiece() {
            let ghostY = currentPiece.y;
            while (!hasCollision(currentPiece, 0, ghostY - currentPiece.y + 1)) {
                ghostY++;
            }

            ctx.globalAlpha = 0.25;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        drawBlock(ctx, currentPiece.x + x, ghostY + y, currentPiece.color, BLOCK_SIZE);
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }

            // Board
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(ctx, x, y, board[y][x], BLOCK_SIZE);
                    }
                }
            }

            // Current piece
            if (currentPiece) {
                drawGhostPiece();

                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x] && currentPiece.y + y >= 0) {
                            drawBlock(ctx, currentPiece.x + x, currentPiece.y + y,
                                currentPiece.color, BLOCK_SIZE, currentPiece.glow);
                        }
                    }
                }
            }
        }

        function drawPiecePreview(ctx, type, size, canvasWidth, canvasHeight) {
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (!type) return;

            const piece = TETROMINOES[type];
            const shape = piece.shape;

            // Find actual bounds
            let minX = shape[0].length, maxX = 0, minY = shape.length, maxY = 0;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            const pieceWidth = (maxX - minX + 1) * size;
            const pieceHeight = (maxY - minY + 1) * size;
            const offsetX = (canvasWidth - pieceWidth) / 2 - minX * size;
            const offsetY = (canvasHeight - pieceHeight) / 2 - minY * size;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const drawX = (offsetX + x * size) / size;
                        const drawY = (offsetY + y * size) / size;
                        drawBlock(ctx, drawX, drawY, piece.color, size, piece.glow);
                    }
                }
            }
        }

        function drawQueue() {
            for (let i = 0; i < 5; i++) {
                const nc = nextCanvases[i];
                const type = pieceQueue[i];
                drawPiecePreview(nc.ctx, type, PREVIEW_BLOCK_SIZE, 80, 50);
            }
        }

        function drawHoldPiece() {
            drawPiecePreview(holdCtx, holdPiece?.type, HOLD_BLOCK_SIZE, 80, 80);

            if (canHold) {
                holdBox.classList.remove('hold-disabled');
            } else {
                holdBox.classList.add('hold-disabled');
            }
        }

        // ===== UI UPDATES =====
        function updateUI() {
            scoreEl.textContent = score.toLocaleString();
            levelEl.textContent = level;
            linesEl.textContent = lines;

            const progressToNext = (lines % 10) / 10 * 100;
            levelProgressEl.style.width = progressToNext + '%';

            document.getElementById('stat-tetrises').textContent = stats.tetrises;
            document.getElementById('stat-tspins').textContent = stats.tspins;
            document.getElementById('stat-combos').textContent = stats.combos;
            document.getElementById('stat-b2b').textContent = stats.b2b;
        }

        function showCombo(count) {
            comboEl.textContent = `${count} COMBO!`;
            comboEl.classList.remove('show');
            void comboEl.offsetWidth;
            comboEl.classList.add('show');
            setTimeout(() => comboEl.classList.remove('show'), 1000);
        }

        function showAction(text) {
            actionEl.textContent = text;
            actionEl.classList.remove('show');
            void actionEl.offsetWidth;
            actionEl.classList.add('show');
        }

        function updateTimer() {
            if (gameMode === 'sprint') {
                const mins = Math.floor(gameTimer / 60);
                const secs = gameTimer % 60;
                timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                gameTimer++;
            } else if (gameMode === 'ultra') {
                const remaining = 120 - gameTimer;
                if (remaining <= 0) {
                    completeGame();
                    return;
                }
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                timerEl.classList.toggle('warning', remaining <= 10);
                gameTimer++;
            }
        }

        // ===== DROP SPEED =====
        function getDropInterval() {
            // Speed curve (milliseconds per row)
            const speeds = [1000, 793, 618, 473, 355, 262, 190, 135, 94, 64, 43, 28, 18, 11, 7];
            return speeds[Math.min(level - 1, speeds.length - 1)];
        }

        // ===== GAME LOOP =====
        function gameLoop(time = 0) {
            if (gameOver || !gameStarted) return;

            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (!paused) {
                // DAS handling
                if (dasDirection !== 0) {
                    dasTimer += deltaTime * 1000;
                    if (!dasActive && dasTimer >= dasDelay) {
                        dasActive = true;
                        dasTimer = 0;
                    }
                    if (dasActive && dasTimer >= dasInterval) {
                        movePiece(dasDirection, 0);
                        dasTimer = 0;
                    }
                }

                // Gravity
                dropCounter += deltaTime * 1000;
                if (dropCounter >= getDropInterval()) {
                    if (!softDrop()) {
                        // Piece is on ground
                        lockDelay += getDropInterval();
                        if (lockDelay >= lockDelayLimit) {
                            lockPiece();
                        }
                    }
                    dropCounter = 0;
                }

                // Update particles
                updateParticles(deltaTime);

                draw();
                drawParticles();
            }

            requestAnimationFrame(gameLoop);
        }

        // ===== GAME CONTROL =====
        function startGame(mode) {
            initAudio();

            gameMode = mode;
            board = createBoard();
            bag = [];
            pieceQueue = [];
            holdPiece = null;
            canHold = true;

            score = 0;
            level = 1;
            lines = 0;
            combo = -1;
            backToBack = false;

            stats = { tetrises: 0, tspins: 0, combos: 0, b2b: 0 };

            gameOver = false;
            paused = false;
            gameStarted = true;
            lastTime = performance.now();
            dropCounter = 0;
            lockDelay = 0;
            lockMoves = 0;

            particles = [];
            gameTimer = 0;

            // Load high scores
            loadHighScores();
            highScoreEl.textContent = (mode === 'sprint' && highScores.sprint !== Infinity)
                ? formatTime(highScores.sprint)
                : highScores[mode].toLocaleString();

            // Timer setup
            if (timerInterval) clearInterval(timerInterval);
            if (mode === 'sprint' || mode === 'ultra') {
                timerEl.classList.remove('hidden');
                timerEl.classList.remove('warning');
                updateTimer();
                timerInterval = setInterval(updateTimer, 1000);
            } else {
                timerEl.classList.add('hidden');
            }

            updateUI();

            startOverlay.classList.add('hidden');
            pauseOverlay.classList.add('hidden');
            gameoverOverlay.classList.add('hidden');
            completeOverlay.classList.add('hidden');

            fillQueue();
            spawnPiece();
            draw();
            drawQueue();
            drawHoldPiece();

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameOver = true;
            gameStarted = false;

            if (timerInterval) clearInterval(timerInterval);

            playGameOverSound();

            finalScoreEl.textContent = score.toLocaleString();

            // Check high score
            if (gameMode === 'marathon' || gameMode === 'ultra') {
                if (score > highScores[gameMode]) {
                    highScores[gameMode] = score;
                    saveHighScores();
                    newHighScoreEl.style.display = 'block';
                } else {
                    newHighScoreEl.style.display = 'none';
                }
            }

            gameoverOverlay.classList.remove('hidden');
        }

        function completeGame() {
            gameOver = true;
            gameStarted = false;

            if (timerInterval) clearInterval(timerInterval);

            if (gameMode === 'sprint') {
                const time = gameTimer;
                completeMessageEl.textContent = `Time: ${formatTime(time)}`;

                if (time < highScores.sprint) {
                    highScores.sprint = time;
                    saveHighScores();
                    completeHighScoreEl.textContent = 'NEW RECORD!';
                } else {
                    completeHighScoreEl.textContent = `Best: ${formatTime(highScores.sprint)}`;
                }
            } else if (gameMode === 'ultra') {
                completeMessageEl.textContent = `Score: ${score.toLocaleString()}`;

                if (score > highScores.ultra) {
                    highScores.ultra = score;
                    saveHighScores();
                    completeHighScoreEl.textContent = 'NEW HIGH SCORE!';
                } else {
                    completeHighScoreEl.textContent = `Best: ${highScores.ultra.toLocaleString()}`;
                }
            }

            completeOverlay.classList.remove('hidden');
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function togglePause() {
            if (gameOver || !gameStarted) return;

            paused = !paused;

            if (paused) {
                if (timerInterval) clearInterval(timerInterval);
                pauseOverlay.classList.remove('hidden');
            } else {
                if (gameMode === 'sprint' || gameMode === 'ultra') {
                    timerInterval = setInterval(updateTimer, 1000);
                }
                pauseOverlay.classList.add('hidden');
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        // ===== HIGH SCORE STORAGE =====
        function loadHighScores() {
            try {
                const saved = localStorage.getItem('tetris6_highscores');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    highScores = { ...highScores, ...parsed };
                }
            } catch (e) {}
        }

        function saveHighScores() {
            try {
                localStorage.setItem('tetris6_highscores', JSON.stringify(highScores));
            } catch (e) {}
        }

        // ===== INPUT HANDLING =====
        const keys = {};

        document.addEventListener('keydown', (e) => {
            if (keys[e.code]) return; // Prevent key repeat
            keys[e.code] = true;

            if (gameOver && !startOverlay.classList.contains('hidden') === false) {
                return;
            }

            if (!gameStarted) return;

            if (e.code === 'KeyP') {
                togglePause();
                return;
            }

            if (paused || gameOver) return;

            switch (e.code) {
                case 'ArrowLeft':
                    e.preventDefault();
                    movePiece(-1, 0);
                    dasDirection = -1;
                    dasTimer = 0;
                    dasActive = false;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    movePiece(1, 0);
                    dasDirection = 1;
                    dasTimer = 0;
                    dasActive = false;
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    softDrop();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    rotate(true);
                    break;
                case 'KeyZ':
                    rotate(false);
                    break;
                case 'Space':
                    e.preventDefault();
                    hardDrop();
                    break;
                case 'KeyE':
                case 'ShiftLeft':
                case 'KeyC':
                    hold();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;

            if (e.code === 'ArrowLeft' && dasDirection === -1) {
                dasDirection = 0;
            }
            if (e.code === 'ArrowRight' && dasDirection === 1) {
                dasDirection = 0;
            }
        });

        // ===== BUTTON HANDLERS =====
        document.getElementById('marathon-btn').addEventListener('click', () => startGame('marathon'));
        document.getElementById('sprint-btn').addEventListener('click', () => startGame('sprint'));
        document.getElementById('ultra-btn').addEventListener('click', () => startGame('ultra'));
        document.getElementById('restart-btn').addEventListener('click', () => startGame(gameMode));
        document.getElementById('complete-restart-btn').addEventListener('click', () => startGame(gameMode));

        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-toggle').textContent = soundEnabled ? 'üîä' : 'üîá';
            if (soundEnabled) initAudio();
        });

        // ===== INITIALIZATION =====
        loadHighScores();
        draw();
        drawQueue();
        drawHoldPiece();
    </script>
</body>
</html>
