<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tetris 7</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            overflow: hidden;
            transition: background 0.5s;
        }

        /* Theme backgrounds */
        body.theme-neon {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
        }
        body.theme-retro {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
        }
        body.theme-ocean {
            background: linear-gradient(135deg, #0077b6 0%, #023e8a 50%, #03045e 100%);
        }
        body.theme-sunset {
            background: linear-gradient(135deg, #f72585 0%, #7209b7 50%, #3a0ca3 100%);
        }
        body.theme-forest {
            background: linear-gradient(135deg, #2d6a4f 0%, #1b4332 50%, #081c15 100%);
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .game-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleShine 3s linear infinite;
            letter-spacing: 10px;
            text-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
        }

        @keyframes titleShine {
            to { background-position: 200% center; }
        }

        .top-bar {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .top-bar button {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .top-bar button:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .game-container {
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 130px;
        }

        .board-wrapper {
            position: relative;
        }

        .board-container {
            position: relative;
            border: 3px solid var(--accent-color, #6c5ce7);
            box-shadow: 0 0 30px var(--glow-color, rgba(108, 92, 231, 0.6));
            border-radius: 5px;
            overflow: hidden;
        }

        #game-board, #effects-canvas {
            display: block;
        }

        #effects-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .panel-box {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-color, #6c5ce7);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .panel-box h3 {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 6px;
            color: var(--accent-light, #a29bfe);
            opacity: 0.8;
        }

        .panel-box .value {
            font-size: 20px;
            font-weight: bold;
        }

        .panel-box .value.score {
            color: #feca57;
            text-shadow: 0 0 10px rgba(254, 202, 87, 0.5);
        }

        .preview-canvas {
            margin: 0 auto;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        .next-queue {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .hold-disabled { opacity: 0.4; }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .progress-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color, #6c5ce7), var(--accent-light, #a29bfe));
            transition: width 0.3s ease;
        }

        /* Power-ups */
        .powerups {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .powerup {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.3);
        }

        .powerup:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }

        .powerup.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .powerup .key {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 8px;
            background: rgba(0,0,0,0.7);
            padding: 1px 3px;
            border-radius: 3px;
        }

        /* Stats grid */
        .stats-mini {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            font-size: 10px;
        }

        .stats-mini .label { color: var(--accent-light, #a29bfe); }
        .stats-mini .stat-value { text-align: right; font-weight: bold; }

        /* Battle mode */
        .battle-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .opponent-board {
            transform: scale(0.6);
            transform-origin: top center;
            opacity: 0.8;
        }

        .opponent-label {
            text-align: center;
            font-size: 14px;
            margin-bottom: 5px;
            color: #ff6b6b;
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 12px;
            border-radius: 5px;
            z-index: 100;
        }

        .overlay.hidden { display: none; }

        .overlay h2 {
            font-size: 28px;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .overlay p {
            font-size: 13px;
            color: #aaa;
        }

        .overlay .final-score {
            font-size: 24px;
            color: #feca57;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .overlay button {
            padding: 10px 25px;
            font-size: 14px;
            background: linear-gradient(135deg, var(--accent-color, #6c5ce7), var(--accent-light, #a29bfe));
            border: none;
            border-radius: 20px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .overlay button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--glow-color, rgba(108, 92, 231, 0.8));
        }

        .overlay button.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--accent-color, #6c5ce7);
        }

        .mode-desc {
            font-size: 10px;
            color: #666;
            margin-top: -8px;
            grid-column: span 2;
            text-align: center;
        }

        /* Achievements */
        .achievement-popup {
            position: fixed;
            top: 20px;
            right: -300px;
            background: linear-gradient(135deg, #feca57, #ff9f43);
            color: #000;
            padding: 15px 20px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 1000;
            transition: right 0.5s ease;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .achievement-popup.show {
            right: 20px;
        }

        .achievement-popup .title {
            font-size: 12px;
            opacity: 0.7;
        }

        .achievement-popup .name {
            font-size: 16px;
        }

        /* Combo display */
        .combo-display {
            position: absolute;
            right: -100px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
            font-weight: bold;
            color: #feca57;
            text-shadow: 0 0 15px rgba(254, 202, 87, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
        }

        .combo-display.show {
            opacity: 1;
            animation: comboPop 0.4s ease;
        }

        @keyframes comboPop {
            0% { transform: translateY(-50%) scale(1.5); }
            100% { transform: translateY(-50%) scale(1); }
        }

        .action-display {
            position: absolute;
            left: 50%;
            top: 35%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px currentColor;
            opacity: 0;
            pointer-events: none;
            text-align: center;
        }

        .action-display.show {
            animation: actionFloat 1.2s ease forwards;
        }

        @keyframes actionFloat {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(1); }
        }

        /* Timer */
        .timer-display {
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #48dbfb;
            text-shadow: 0 0 10px rgba(72, 219, 251, 0.5);
            z-index: 50;
        }

        .timer-display.warning {
            color: #ff6b6b;
            animation: pulse 0.5s ease infinite alternate;
        }

        @keyframes pulse {
            to { opacity: 0.5; }
        }

        /* Garbage indicator */
        .garbage-meter {
            position: absolute;
            left: -20px;
            bottom: 0;
            width: 12px;
            height: 100%;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        .garbage-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff6b6b, #ee5a5a);
            transition: height 0.3s;
            border-radius: 6px;
        }

        /* Mobile touch controls */
        .touch-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        .touch-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
        }

        .touch-btn:active {
            background: rgba(255,255,255,0.3);
            transform: scale(0.95);
        }

        .touch-btn.wide {
            width: 130px;
        }

        @media (max-width: 900px) {
            .touch-controls { display: block; }
            .game-wrapper { transform: scale(0.7); transform-origin: top center; }
        }

        /* Theme selector in overlay */
        .theme-selector {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }

        .theme-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-btn:hover, .theme-btn.active {
            transform: scale(1.2);
            border-color: #fff;
        }

        .theme-btn.neon { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
        .theme-btn.retro { background: linear-gradient(135deg, #e74c3c, #f39c12); }
        .theme-btn.ocean { background: linear-gradient(135deg, #0077b6, #00b4d8); }
        .theme-btn.sunset { background: linear-gradient(135deg, #f72585, #7209b7); }
        .theme-btn.forest { background: linear-gradient(135deg, #40916c, #2d6a4f); }

        /* Screen shake */
        .shake {
            animation: shake 0.2s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* All clear effect */
        .all-clear {
            animation: allClear 1s ease;
        }

        @keyframes allClear {
            0%, 100% { box-shadow: 0 0 30px var(--glow-color); }
            50% { box-shadow: 0 0 60px #feca57, 0 0 100px #feca57; }
        }
    </style>
</head>
<body class="theme-neon">
    <!-- Achievement popup -->
    <div class="achievement-popup" id="achievement-popup">
        <div class="title">ACHIEVEMENT UNLOCKED</div>
        <div class="name" id="achievement-name"></div>
    </div>

    <div class="game-wrapper">
        <div class="game-title">TETRIS 7</div>

        <div class="top-bar">
            <button id="sound-btn">üîä Sound</button>
            <button id="music-btn">üéµ Music</button>
            <button id="theme-btn">üé® Theme</button>
        </div>

        <div class="game-container" id="main-container">
            <div class="panel" id="left-panel">
                <div class="panel-box" id="hold-box">
                    <h3>Hold [E]</h3>
                    <canvas class="preview-canvas" id="hold-piece" width="70" height="70"></canvas>
                </div>

                <div class="panel-box">
                    <h3>Score</h3>
                    <div class="value score" id="score">0</div>
                </div>

                <div class="panel-box">
                    <h3>Level</h3>
                    <div class="value" id="level">1</div>
                    <div class="progress-bar">
                        <div class="fill" id="level-progress"></div>
                    </div>
                </div>

                <div class="panel-box">
                    <h3>Lines</h3>
                    <div class="value" id="lines">0</div>
                </div>

                <div class="panel-box">
                    <h3>Power-Ups</h3>
                    <div class="powerups" id="powerups">
                        <div class="powerup disabled" id="pow-bomb" title="Bomb: Clear 3x3 area [1]">üí£</div>
                        <div class="powerup disabled" id="pow-slow" title="Slow: Half speed for 10s [2]">üê¢</div>
                        <div class="powerup disabled" id="pow-clear" title="Clear: Remove bottom row [3]">üßπ</div>
                        <div class="powerup disabled" id="pow-ghost" title="Ghost: See 2 more pieces [4]">üëª</div>
                    </div>
                </div>
            </div>

            <div class="board-wrapper">
                <div class="garbage-meter">
                    <div class="garbage-fill" id="garbage-fill"></div>
                </div>
                <div class="board-container" id="board-container">
                    <canvas id="game-board" width="300" height="600"></canvas>
                    <canvas id="effects-canvas" width="300" height="600"></canvas>
                    <div class="timer-display hidden" id="timer"></div>
                    <div class="combo-display" id="combo"></div>
                    <div class="action-display" id="action"></div>

                    <!-- Start Overlay -->
                    <div id="start-overlay" class="overlay">
                        <h2>TETRIS 7</h2>
                        <p>Select Theme</p>
                        <div class="theme-selector">
                            <div class="theme-btn neon active" data-theme="neon"></div>
                            <div class="theme-btn retro" data-theme="retro"></div>
                            <div class="theme-btn ocean" data-theme="ocean"></div>
                            <div class="theme-btn sunset" data-theme="sunset"></div>
                            <div class="theme-btn forest" data-theme="forest"></div>
                        </div>
                        <p>Choose Mode</p>
                        <div class="mode-grid">
                            <button id="mode-marathon">MARATHON</button>
                            <button id="mode-sprint" class="secondary">SPRINT 40</button>
                            <p class="mode-desc">Classic / Clear 40 lines</p>
                            <button id="mode-ultra" class="secondary">ULTRA 2:00</button>
                            <button id="mode-zen" class="secondary">ZEN</button>
                            <p class="mode-desc">Timed score / No game over</p>
                            <button id="mode-battle" class="secondary">VS CPU</button>
                            <button id="mode-puzzle" class="secondary">PUZZLE</button>
                            <p class="mode-desc">Battle AI / Clear challenges</p>
                        </div>
                    </div>

                    <!-- Pause Overlay -->
                    <div id="pause-overlay" class="overlay hidden">
                        <h2>PAUSED</h2>
                        <p>Press P to resume</p>
                        <button id="resume-btn">Resume</button>
                    </div>

                    <!-- Game Over Overlay -->
                    <div id="gameover-overlay" class="overlay hidden">
                        <h2>GAME OVER</h2>
                        <div class="final-score">Score: <span id="final-score">0</span></div>
                        <p id="high-score-msg"></p>
                        <button id="restart-btn">Play Again</button>
                        <button id="menu-btn" class="secondary">Main Menu</button>
                    </div>

                    <!-- Complete Overlay -->
                    <div id="complete-overlay" class="overlay hidden">
                        <h2 id="complete-title">COMPLETE!</h2>
                        <div class="final-score" id="complete-score"></div>
                        <p id="complete-msg"></p>
                        <button id="complete-restart-btn">Play Again</button>
                        <button id="complete-menu-btn" class="secondary">Main Menu</button>
                    </div>

                    <!-- Puzzle Overlay -->
                    <div id="puzzle-overlay" class="overlay hidden">
                        <h2>PUZZLE MODE</h2>
                        <p>Clear the highlighted lines!</p>
                        <p id="puzzle-level">Level 1</p>
                        <button id="puzzle-start-btn">Start</button>
                    </div>
                </div>
            </div>

            <div class="panel" id="right-panel">
                <div class="panel-box">
                    <h3>Next</h3>
                    <div class="next-queue" id="next-queue"></div>
                </div>

                <div class="panel-box">
                    <h3>Stats</h3>
                    <div class="stats-mini">
                        <span class="label">Tetrises</span>
                        <span class="stat-value" id="stat-tetrises">0</span>
                        <span class="label">T-Spins</span>
                        <span class="stat-value" id="stat-tspins">0</span>
                        <span class="label">All Clears</span>
                        <span class="stat-value" id="stat-allclears">0</span>
                        <span class="label">Max Combo</span>
                        <span class="stat-value" id="stat-combo">0</span>
                        <span class="label">Pieces</span>
                        <span class="stat-value" id="stat-pieces">0</span>
                        <span class="label">PPS</span>
                        <span class="stat-value" id="stat-pps">0.00</span>
                    </div>
                </div>

                <div class="panel-box">
                    <h3>Best</h3>
                    <div class="value" id="high-score">0</div>
                </div>

                <div class="panel-box">
                    <h3>Controls</h3>
                    <div class="stats-mini" style="font-size:9px">
                        <span>‚Üê‚Üí</span><span>Move</span>
                        <span>‚Üë</span><span>Rotate</span>
                        <span>‚Üì</span><span>Soft Drop</span>
                        <span>Space</span><span>Hard Drop</span>
                        <span>E/C</span><span>Hold</span>
                        <span>Z</span><span>Rotate CCW</span>
                        <span>1-4</span><span>Power-ups</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Touch Controls -->
    <div class="touch-controls" id="touch-controls">
        <div class="touch-row">
            <div class="touch-btn" id="touch-ccw">‚Ü∫</div>
            <div class="touch-btn" id="touch-hold">‚¨°</div>
            <div class="touch-btn" id="touch-cw">‚Üª</div>
        </div>
        <div class="touch-row">
            <div class="touch-btn" id="touch-left">‚Üê</div>
            <div class="touch-btn" id="touch-down">‚Üì</div>
            <div class="touch-btn" id="touch-right">‚Üí</div>
        </div>
        <div class="touch-row">
            <div class="touch-btn wide" id="touch-drop">DROP</div>
        </div>
    </div>

    <script>
        // ============== CONSTANTS ==============
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const PREVIEW_SIZE = 14;

        // ============== TETROMINOES (12 pieces including 3 new) ==============
        const TETROMINOES = {
            I: { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], color: '#00f5ff' },
            O: { shape: [[1,1],[1,1]], color: '#ffeb3b' },
            T: { shape: [[0,1,0],[1,1,1],[0,0,0]], color: '#e040fb' },
            S: { shape: [[0,1,1],[1,1,0],[0,0,0]], color: '#76ff03' },
            Z: { shape: [[1,1,0],[0,1,1],[0,0,0]], color: '#ff5252' },
            J: { shape: [[1,0,0],[1,1,1],[0,0,0]], color: '#448aff' },
            L: { shape: [[0,0,1],[1,1,1],[0,0,0]], color: '#ff9100' },
            // New pieces from Tetris 6
            P: { shape: [[0,1,0],[1,1,1],[0,1,0]], color: '#ff69b4' }, // Plus
            U: { shape: [[1,0,1],[1,1,1],[0,0,0]], color: '#40e0d0' }, // U-shape
            // NEW in Tetris 7
            X: { shape: [[1,0,1],[0,1,0],[1,0,1]], color: '#ffd700' }, // X-shape (corners)
            H: { shape: [[1,0,1],[1,1,1],[1,0,1]], color: '#ff1493' }, // H-shape
            W: { shape: [[1,0,0],[1,1,0],[0,1,1]], color: '#00ced1' }  // W/stairs
        };

        const PIECE_NAMES = Object.keys(TETROMINOES);

        // SRS Wall Kicks
        const KICKS = {
            normal: {
                '0>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
                '1>0': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
                '1>2': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
                '2>1': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
                '2>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
                '3>2': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
                '3>0': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
                '0>3': [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
            },
            I: {
                '0>1': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
                '1>0': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
                '1>2': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
                '2>1': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
                '2>3': [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
                '3>2': [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
                '3>0': [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
                '0>3': [[0,0],[-1,0],[2,0],[-1,2],[2,-1]]
            }
        };

        // Theme colors
        const THEMES = {
            neon: { accent: '#6c5ce7', light: '#a29bfe', glow: 'rgba(108,92,231,0.6)' },
            retro: { accent: '#e74c3c', light: '#f39c12', glow: 'rgba(231,76,60,0.6)' },
            ocean: { accent: '#0077b6', light: '#00b4d8', glow: 'rgba(0,119,182,0.6)' },
            sunset: { accent: '#f72585', light: '#b5179e', glow: 'rgba(247,37,133,0.6)' },
            forest: { accent: '#40916c', light: '#74c69d', glow: 'rgba(64,145,108,0.6)' }
        };

        // Achievements
        const ACHIEVEMENTS = {
            firstTetris: { name: 'First Tetris!', condition: s => s.tetrises >= 1 },
            combo5: { name: 'Combo Master', condition: s => s.maxCombo >= 5 },
            tspin3: { name: 'T-Spin Pro', condition: s => s.tspins >= 3 },
            allClear: { name: 'Perfect Clear', condition: s => s.allClears >= 1 },
            level10: { name: 'Speed Demon', condition: s => s.level >= 10 },
            pieces100: { name: 'Century', condition: s => s.pieces >= 100 },
            score50k: { name: 'High Roller', condition: s => s.score >= 50000 },
            b2b5: { name: 'Back to Back x5', condition: s => s.b2bCount >= 5 }
        };

        // ============== GAME STATE ==============
        let board = [];
        let currentPiece = null;
        let holdPiece = null;
        let canHold = true;
        let pieceQueue = [];
        let bag = [];

        let score = 0;
        let level = 1;
        let lines = 0;
        let combo = -1;
        let backToBack = false;
        let b2bCount = 0;

        let gameOver = false;
        let paused = false;
        let gameStarted = false;
        let gameMode = 'marathon';
        let currentTheme = 'neon';

        let lastTime = 0;
        let dropCounter = 0;
        let lockDelay = 0;
        let lockMoves = 0;
        let gameTime = 0;

        // DAS
        let dasDelay = 170;
        let dasInterval = 50;
        let dasTimer = 0;
        let dasDir = 0;
        let dasActive = false;

        // Stats
        let stats = {
            tetrises: 0, tspins: 0, allClears: 0, maxCombo: 0,
            pieces: 0, b2bCount: 0, score: 0, level: 1
        };

        // Power-ups
        let powerups = { bomb: 0, slow: 0, clear: 0, ghost: 0 };
        let slowModeActive = false;
        let slowModeTimer = 0;
        let extraPreviews = 0;

        // Effects
        let particles = [];
        let screenShake = 0;

        // Garbage (for battle mode)
        let pendingGarbage = 0;

        // AI opponent (battle mode)
        let aiBoard = [];
        let aiPiece = null;
        let aiScore = 0;
        let aiLines = 0;

        // Puzzle mode
        let puzzleLevel = 1;
        let puzzleTargetLines = [];

        // Timer
        let timerValue = 0;
        let timerInterval = null;

        // Audio
        let soundEnabled = true;
        let musicEnabled = false;
        let audioCtx = null;
        let musicOsc = null;

        // Achievements unlocked
        let unlockedAchievements = new Set();

        // High scores
        let highScores = { marathon: 0, sprint: Infinity, ultra: 0 };

        // ============== CANVAS SETUP ==============
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const effectsCanvas = document.getElementById('effects-canvas');
        const effectsCtx = effectsCanvas.getContext('2d');
        const holdCanvas = document.getElementById('hold-piece');
        const holdCtx = holdCanvas.getContext('2d');

        // Create next queue canvases dynamically
        const nextQueueEl = document.getElementById('next-queue');
        const nextCanvases = [];
        for (let i = 0; i < 6; i++) {
            const c = document.createElement('canvas');
            c.width = 70;
            c.height = 45;
            c.className = 'preview-canvas';
            nextQueueEl.appendChild(c);
            nextCanvases.push({ canvas: c, ctx: c.getContext('2d') });
        }

        // ============== AUDIO ==============
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone(freq, dur, type = 'square', vol = 0.08) {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.value = vol;
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        function playMove() { playTone(220, 0.04); }
        function playRotate() { playTone(330, 0.06); }
        function playDrop() { playTone(110, 0.1, 'triangle'); }
        function playLock() { playTone(90, 0.12, 'triangle'); }
        function playClear(n) {
            for (let i = 0; i < n; i++) {
                setTimeout(() => playTone(400 + i * 100, 0.15, 'sine', 0.1), i * 50);
            }
        }
        function playTetris() {
            [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'sine', 0.1), i * 70));
        }
        function playAllClear() {
            [523, 659, 784, 880, 1047, 1175, 1319].forEach((f, i) =>
                setTimeout(() => playTone(f, 0.25, 'sine', 0.12), i * 60));
        }
        function playGameOver() {
            [400, 350, 300, 250, 200].forEach((f, i) => setTimeout(() => playTone(f, 0.3, 'sawtooth', 0.06), i * 120));
        }
        function playPowerup() {
            playTone(600, 0.1, 'sine', 0.1);
            setTimeout(() => playTone(800, 0.15, 'sine', 0.1), 80);
        }
        function playAchievement() {
            [880, 1047, 1319, 1568].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'sine', 0.1), i * 100));
        }

        // Simple procedural music
        function startMusic() {
            if (!musicEnabled || !audioCtx) return;
            const notes = [262, 294, 330, 349, 392, 440, 494, 523];
            let noteIndex = 0;

            function playNote() {
                if (!musicEnabled) return;
                const freq = notes[noteIndex % notes.length] * (Math.floor(noteIndex / 8) % 2 === 0 ? 1 : 0.5);
                playTone(freq, 0.2, 'triangle', 0.03);
                noteIndex++;
                setTimeout(playNote, 250);
            }
            playNote();
        }

        // ============== PARTICLES ==============
        function spawnParticles(row, color) {
            const y = row * BLOCK_SIZE + BLOCK_SIZE / 2;
            for (let x = 0; x < COLS; x++) {
                for (let i = 0; i < 4; i++) {
                    particles.push({
                        x: x * BLOCK_SIZE + BLOCK_SIZE / 2,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10 - 4,
                        life: 1,
                        color: color || `hsl(${Math.random() * 60 + 30}, 100%, 60%)`,
                        size: Math.random() * 5 + 2
                    });
                }
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= dt * 2.5;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            effectsCtx.clearRect(0, 0, effectsCanvas.width, effectsCanvas.height);
            particles.forEach(p => {
                effectsCtx.globalAlpha = p.life;
                effectsCtx.fillStyle = p.color;
                effectsCtx.beginPath();
                effectsCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                effectsCtx.fill();
            });
            effectsCtx.globalAlpha = 1;
        }

        // ============== 7-BAG RANDOMIZER ==============
        function fillBag() {
            bag = [...PIECE_NAMES];
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
        }

        function getNextPiece() {
            if (bag.length === 0) fillBag();
            return bag.pop();
        }

        function fillQueue() {
            const needed = 6 + extraPreviews;
            while (pieceQueue.length < needed) {
                pieceQueue.push(getNextPiece());
            }
        }

        // ============== BOARD ==============
        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        }

        function createPiece(type) {
            const t = TETROMINOES[type];
            return {
                type,
                shape: t.shape.map(r => [...r]),
                color: t.color,
                x: Math.floor(COLS / 2) - Math.ceil(t.shape[0].length / 2),
                y: 0,
                rotation: 0
            };
        }

        // ============== COLLISION ==============
        function hasCollision(piece, ox = 0, oy = 0, shape = piece.shape) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const nx = piece.x + x + ox;
                        const ny = piece.y + y + oy;
                        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                        if (ny >= 0 && board[ny][nx]) return true;
                    }
                }
            }
            return false;
        }

        // ============== ROTATION ==============
        function rotateMatrix(m, cw = true) {
            const rows = m.length, cols = m[0].length;
            const r = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (cw) r[x][rows - 1 - y] = m[y][x];
                    else r[cols - 1 - x][y] = m[y][x];
                }
            }
            return r;
        }

        function rotate(cw = true) {
            if (currentPiece.type === 'O') return false;
            const rotated = rotateMatrix(currentPiece.shape, cw);
            const oldRot = currentPiece.rotation;
            const newRot = cw ? (oldRot + 1) % 4 : (oldRot + 3) % 4;
            const key = `${oldRot}>${newRot}`;
            const kicks = currentPiece.type === 'I' ? KICKS.I[key] : KICKS.normal[key];

            for (const [kx, ky] of kicks) {
                if (!hasCollision(currentPiece, kx, -ky, rotated)) {
                    currentPiece.x += kx;
                    currentPiece.y -= ky;
                    currentPiece.shape = rotated;
                    currentPiece.rotation = newRot;
                    playRotate();
                    resetLockDelay();
                    return true;
                }
            }
            return false;
        }

        // ============== T-SPIN DETECTION ==============
        function detectTSpin() {
            if (currentPiece.type !== 'T') return false;
            const corners = [[0,0],[2,0],[0,2],[2,2]];
            let filled = 0;
            for (const [cx, cy] of corners) {
                const bx = currentPiece.x + cx;
                const by = currentPiece.y + cy;
                if (bx < 0 || bx >= COLS || by >= ROWS || (by >= 0 && board[by][bx])) filled++;
            }
            return filled >= 3;
        }

        // ============== LOCK PIECE ==============
        function lockPiece() {
            const isTSpin = detectTSpin();

            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const by = currentPiece.y + y;
                        const bx = currentPiece.x + x;
                        if (by < 0) {
                            if (gameMode !== 'zen') endGame();
                            return;
                        }
                        board[by][bx] = currentPiece.color;
                    }
                }
            }

            stats.pieces++;
            playLock();
            clearLines(isTSpin);

            // Add garbage after piece locks
            if (pendingGarbage > 0) {
                addGarbage(pendingGarbage);
                pendingGarbage = 0;
                updateGarbageMeter();
            }

            spawnPiece();
        }

        // ============== LINE CLEARING ==============
        function clearLines(isTSpin) {
            let cleared = 0;
            let clearedRows = [];

            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(c => c !== null)) {
                    clearedRows.push(y);
                    cleared++;
                }
            }

            if (cleared > 0) {
                clearedRows.forEach(row => {
                    spawnParticles(row);
                    board.splice(row, 1);
                    board.unshift(Array(COLS).fill(null));
                });

                screenShake = 0.15;
                document.getElementById('board-container').classList.add('shake');
                setTimeout(() => document.getElementById('board-container').classList.remove('shake'), 200);

                playClear(cleared);

                combo++;
                stats.maxCombo = Math.max(stats.maxCombo, combo);
                if (combo > 0) showCombo(combo);

                // Calculate score
                let points = 0;
                let actionText = '';
                let isDifficult = false;

                if (isTSpin) {
                    stats.tspins++;
                    isDifficult = true;
                    points = [0, 800, 1200, 1600][cleared] || 0;
                    actionText = `T-SPIN ${['', 'SINGLE', 'DOUBLE', 'TRIPLE'][cleared]}`;
                } else {
                    points = [0, 100, 300, 500, 800][cleared] || 0;
                    actionText = ['', 'SINGLE', 'DOUBLE', 'TRIPLE', 'TETRIS!'][cleared];
                    if (cleared === 4) {
                        isDifficult = true;
                        stats.tetrises++;
                        playTetris();
                    }
                }

                // Check all clear
                if (board.every(row => row.every(c => c === null))) {
                    points += 3000 * level;
                    actionText = 'ALL CLEAR!';
                    stats.allClears++;
                    playAllClear();
                    document.getElementById('board-container').classList.add('all-clear');
                    setTimeout(() => document.getElementById('board-container').classList.remove('all-clear'), 1000);

                    // Award power-up for all clear
                    awardPowerup();
                }

                // Back-to-back
                if (isDifficult) {
                    if (backToBack) {
                        points = Math.floor(points * 1.5);
                        actionText = 'B2B ' + actionText;
                        b2bCount++;
                        stats.b2bCount = b2bCount;
                    }
                    backToBack = true;
                } else {
                    backToBack = false;
                    b2bCount = 0;
                }

                // Combo bonus
                if (combo > 0) points += 50 * combo * level;

                points *= level;
                score += points;
                lines += cleared;
                stats.score = score;

                showAction(actionText);

                // Level up
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = Math.min(newLevel, 20);
                    stats.level = level;
                    // Award power-up on level up
                    if (level % 3 === 0) awardPowerup();
                }

                // Battle mode: send garbage to opponent
                if (gameMode === 'battle' && cleared > 1) {
                    aiReceiveGarbage(cleared - 1);
                }

                // Sprint check
                if (gameMode === 'sprint' && lines >= 40) {
                    completeGame();
                }

                checkAchievements();
                updateUI();
            } else {
                combo = -1;
            }
        }

        // ============== GARBAGE ==============
        function addGarbage(rows) {
            for (let i = 0; i < rows; i++) {
                board.shift();
                const garbageRow = Array(COLS).fill('#555');
                garbageRow[Math.floor(Math.random() * COLS)] = null;
                board.push(garbageRow);
            }
        }

        function updateGarbageMeter() {
            const fill = document.getElementById('garbage-fill');
            fill.style.height = Math.min(pendingGarbage * 5, 100) + '%';
        }

        // ============== SPAWNING ==============
        function spawnPiece() {
            fillQueue();
            currentPiece = createPiece(pieceQueue.shift());
            canHold = true;
            lockDelay = 0;
            lockMoves = 0;

            if (hasCollision(currentPiece)) {
                if (gameMode !== 'zen') endGame();
            }

            drawQueue();
            drawHold();
        }

        // ============== HOLD ==============
        function hold() {
            if (!canHold) return;
            canHold = false;
            playRotate();

            if (!holdPiece) {
                holdPiece = createPiece(currentPiece.type);
                fillQueue();
                currentPiece = createPiece(pieceQueue.shift());
            } else {
                const temp = currentPiece.type;
                currentPiece = createPiece(holdPiece.type);
                holdPiece = createPiece(temp);
            }

            lockDelay = 0;
            lockMoves = 0;
            drawQueue();
            drawHold();
        }

        // ============== MOVEMENT ==============
        function move(dx, dy) {
            if (!hasCollision(currentPiece, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                if (dx !== 0) playMove();
                resetLockDelay();
                return true;
            }
            return false;
        }

        function hardDrop() {
            let dist = 0;
            while (!hasCollision(currentPiece, 0, 1)) {
                currentPiece.y++;
                dist++;
            }
            score += dist * 2;
            playDrop();
            lockPiece();
            updateUI();
        }

        function softDrop() {
            if (move(0, 1)) {
                score++;
                updateUI();
                return true;
            }
            return false;
        }

        function resetLockDelay() {
            if (hasCollision(currentPiece, 0, 1)) {
                lockMoves++;
                if (lockMoves < 15) lockDelay = 0;
            }
        }

        // ============== POWER-UPS ==============
        function awardPowerup() {
            const types = ['bomb', 'slow', 'clear', 'ghost'];
            const type = types[Math.floor(Math.random() * types.length)];
            powerups[type]++;
            updatePowerupUI();
            playPowerup();
            showAction(`+${type.toUpperCase()}!`);
        }

        function usePowerup(type) {
            if (powerups[type] <= 0 || paused || gameOver) return;
            powerups[type]--;
            playPowerup();

            switch (type) {
                case 'bomb':
                    // Clear 3x3 around current piece center
                    const cx = currentPiece.x + 1;
                    const cy = currentPiece.y + 1;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const y = cy + dy;
                            const x = cx + dx;
                            if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                                board[y][x] = null;
                            }
                        }
                    }
                    spawnParticles(cy, '#ff6b6b');
                    break;
                case 'slow':
                    slowModeActive = true;
                    slowModeTimer = 10;
                    showAction('SLOW MODE!');
                    break;
                case 'clear':
                    // Remove bottom row
                    board.pop();
                    board.unshift(Array(COLS).fill(null));
                    spawnParticles(ROWS - 1, '#76ff03');
                    break;
                case 'ghost':
                    // See 2 extra pieces temporarily
                    extraPreviews = 2;
                    fillQueue();
                    drawQueue();
                    setTimeout(() => { extraPreviews = 0; drawQueue(); }, 15000);
                    showAction('+2 PREVIEW!');
                    break;
            }

            updatePowerupUI();
        }

        function updatePowerupUI() {
            ['bomb', 'slow', 'clear', 'ghost'].forEach(type => {
                const el = document.getElementById(`pow-${type}`);
                if (powerups[type] > 0) {
                    el.classList.remove('disabled');
                    el.textContent = { bomb: 'üí£', slow: 'üê¢', clear: 'üßπ', ghost: 'üëª' }[type] +
                        (powerups[type] > 1 ? powerups[type] : '');
                } else {
                    el.classList.add('disabled');
                    el.textContent = { bomb: 'üí£', slow: 'üê¢', clear: 'üßπ', ghost: 'üëª' }[type];
                }
            });
        }

        // ============== ACHIEVEMENTS ==============
        function checkAchievements() {
            for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
                if (!unlockedAchievements.has(id) && ach.condition(stats)) {
                    unlockedAchievements.add(id);
                    showAchievement(ach.name);
                }
            }
        }

        function showAchievement(name) {
            playAchievement();
            const popup = document.getElementById('achievement-popup');
            document.getElementById('achievement-name').textContent = name;
            popup.classList.add('show');
            setTimeout(() => popup.classList.remove('show'), 3000);
        }

        // ============== AI OPPONENT ==============
        function initAI() {
            aiBoard = createBoard();
            aiScore = 0;
            aiLines = 0;
        }

        function aiReceiveGarbage(rows) {
            for (let i = 0; i < rows; i++) {
                aiBoard.shift();
                const row = Array(COLS).fill('#777');
                row[Math.floor(Math.random() * COLS)] = null;
                aiBoard.push(row);
            }
        }

        function aiTick() {
            if (gameMode !== 'battle' || gameOver || paused) return;

            // Simple AI: randomly place pieces and clear lines
            if (Math.random() < 0.05) {
                // Add a random piece to a random column
                const col = Math.floor(Math.random() * (COLS - 2));
                const color = '#888';
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (!aiBoard[y][col]) {
                        aiBoard[y][col] = color;
                        aiBoard[y][col + 1] = color;
                        if (y > 0) {
                            aiBoard[y-1][col] = color;
                            aiBoard[y-1][col + 1] = color;
                        }
                        break;
                    }
                }
            }

            // Clear lines
            for (let y = ROWS - 1; y >= 0; y--) {
                if (aiBoard[y].every(c => c !== null)) {
                    aiBoard.splice(y, 1);
                    aiBoard.unshift(Array(COLS).fill(null));
                    aiLines++;
                    aiScore += 100;
                    // Send garbage to player
                    if (Math.random() < 0.3) {
                        pendingGarbage++;
                        updateGarbageMeter();
                    }
                }
            }
        }

        // ============== DRAWING ==============
        function drawBlock(ctx, x, y, color, size, glow = false) {
            ctx.fillStyle = color;
            ctx.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillRect(x * size + 1, y * size + 1, size - 2, 3);
            ctx.fillRect(x * size + 1, y * size + 1, 3, size - 2);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(x * size + 1, y * size + size - 4, size - 2, 3);
            ctx.fillRect(x * size + size - 4, y * size + 1, 3, size - 2);

            if (glow) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.strokeRect(x * size + 1, y * size + 1, size - 2, size - 2);
                ctx.shadowBlur = 0;
            }
        }

        function drawGhost() {
            let gy = currentPiece.y;
            while (!hasCollision(currentPiece, 0, gy - currentPiece.y + 1)) gy++;

            ctx.globalAlpha = 0.2;
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        drawBlock(ctx, currentPiece.x + x, gy + y, currentPiece.color, BLOCK_SIZE);
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }

            // Board
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(ctx, x, y, board[y][x], BLOCK_SIZE);
                    }
                }
            }

            // Current piece
            if (currentPiece) {
                drawGhost();
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x] && currentPiece.y + y >= 0) {
                            drawBlock(ctx, currentPiece.x + x, currentPiece.y + y,
                                currentPiece.color, BLOCK_SIZE, true);
                        }
                    }
                }
            }
        }

        function drawPreview(ctx, type, w, h) {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, w, h);
            if (!type) return;

            const piece = TETROMINOES[type];
            const shape = piece.shape;

            // Find bounds
            let minX = shape[0].length, maxX = 0, minY = shape.length, maxY = 0;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            const pw = (maxX - minX + 1) * PREVIEW_SIZE;
            const ph = (maxY - minY + 1) * PREVIEW_SIZE;
            const ox = (w - pw) / 2 - minX * PREVIEW_SIZE;
            const oy = (h - ph) / 2 - minY * PREVIEW_SIZE;

            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        drawBlock(ctx, (ox + x * PREVIEW_SIZE) / PREVIEW_SIZE,
                            (oy + y * PREVIEW_SIZE) / PREVIEW_SIZE, piece.color, PREVIEW_SIZE, true);
                    }
                }
            }
        }

        function drawQueue() {
            const count = Math.min(6 + extraPreviews, nextCanvases.length);
            for (let i = 0; i < count; i++) {
                const nc = nextCanvases[i];
                nc.canvas.style.display = i < 6 + extraPreviews ? 'block' : 'none';
                drawPreview(nc.ctx, pieceQueue[i], 70, 45);
            }
        }

        function drawHold() {
            drawPreview(holdCtx, holdPiece?.type, 70, 70);
            document.getElementById('hold-box').classList.toggle('hold-disabled', !canHold);
        }

        // ============== UI ==============
        function updateUI() {
            document.getElementById('score').textContent = score.toLocaleString();
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level-progress').style.width = ((lines % 10) / 10 * 100) + '%';

            document.getElementById('stat-tetrises').textContent = stats.tetrises;
            document.getElementById('stat-tspins').textContent = stats.tspins;
            document.getElementById('stat-allclears').textContent = stats.allClears;
            document.getElementById('stat-combo').textContent = stats.maxCombo;
            document.getElementById('stat-pieces').textContent = stats.pieces;

            const pps = gameTime > 0 ? (stats.pieces / gameTime).toFixed(2) : '0.00';
            document.getElementById('stat-pps').textContent = pps;
        }

        function showCombo(n) {
            const el = document.getElementById('combo');
            el.textContent = `${n} COMBO!`;
            el.classList.remove('show');
            void el.offsetWidth;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1000);
        }

        function showAction(text) {
            const el = document.getElementById('action');
            el.textContent = text;
            el.classList.remove('show');
            void el.offsetWidth;
            el.classList.add('show');
        }

        // ============== TIMER ==============
        function updateTimer() {
            timerValue++;
            const el = document.getElementById('timer');

            if (gameMode === 'sprint') {
                const m = Math.floor(timerValue / 60);
                const s = timerValue % 60;
                el.textContent = `${m}:${s.toString().padStart(2, '0')}`;
            } else if (gameMode === 'ultra') {
                const remaining = 120 - timerValue;
                if (remaining <= 0) {
                    completeGame();
                    return;
                }
                const m = Math.floor(remaining / 60);
                const s = remaining % 60;
                el.textContent = `${m}:${s.toString().padStart(2, '0')}`;
                el.classList.toggle('warning', remaining <= 10);
            }
        }

        // ============== DROP SPEED ==============
        function getDropSpeed() {
            const speeds = [1000,793,618,473,355,262,190,135,94,64,43,28,18,11,7,7,7,7,7,7];
            let speed = speeds[Math.min(level - 1, speeds.length - 1)];
            if (slowModeActive) speed *= 2;
            return speed;
        }

        // ============== GAME LOOP ==============
        function gameLoop(time = 0) {
            if (gameOver || !gameStarted) return;

            const dt = (time - lastTime) / 1000;
            lastTime = time;
            gameTime += dt;

            if (!paused) {
                // Slow mode timer
                if (slowModeActive) {
                    slowModeTimer -= dt;
                    if (slowModeTimer <= 0) slowModeActive = false;
                }

                // DAS
                if (dasDir !== 0) {
                    dasTimer += dt * 1000;
                    if (!dasActive && dasTimer >= dasDelay) {
                        dasActive = true;
                        dasTimer = 0;
                    }
                    if (dasActive && dasTimer >= dasInterval) {
                        move(dasDir, 0);
                        dasTimer = 0;
                    }
                }

                // Gravity
                dropCounter += dt * 1000;
                if (dropCounter >= getDropSpeed()) {
                    if (!softDrop()) {
                        lockDelay += getDropSpeed();
                        if (lockDelay >= 500) lockPiece();
                    }
                    dropCounter = 0;
                }

                // AI tick
                aiTick();

                updateParticles(dt);
                draw();
                drawParticles();
            }

            requestAnimationFrame(gameLoop);
        }

        // ============== GAME CONTROL ==============
        function startGame(mode) {
            initAudio();
            if (musicEnabled) startMusic();

            gameMode = mode;
            board = createBoard();
            bag = [];
            pieceQueue = [];
            holdPiece = null;
            canHold = true;
            extraPreviews = 0;

            score = 0;
            level = 1;
            lines = 0;
            combo = -1;
            backToBack = false;
            b2bCount = 0;
            pendingGarbage = 0;

            stats = { tetrises: 0, tspins: 0, allClears: 0, maxCombo: 0, pieces: 0, b2bCount: 0, score: 0, level: 1 };
            powerups = { bomb: 0, slow: 0, clear: 0, ghost: 0 };
            slowModeActive = false;
            particles = [];

            gameOver = false;
            paused = false;
            gameStarted = true;
            lastTime = performance.now();
            dropCounter = 0;
            lockDelay = 0;
            lockMoves = 0;
            gameTime = 0;
            timerValue = 0;

            if (mode === 'battle') initAI();

            loadHighScores();
            document.getElementById('high-score').textContent =
                (mode === 'sprint' && highScores.sprint !== Infinity)
                    ? formatTime(highScores.sprint)
                    : (highScores[mode] || 0).toLocaleString();

            // Timer
            if (timerInterval) clearInterval(timerInterval);
            const timerEl = document.getElementById('timer');
            if (mode === 'sprint' || mode === 'ultra') {
                timerEl.classList.remove('hidden');
                timerEl.classList.remove('warning');
                timerEl.textContent = mode === 'ultra' ? '2:00' : '0:00';
                timerInterval = setInterval(updateTimer, 1000);
            } else {
                timerEl.classList.add('hidden');
            }

            updateUI();
            updatePowerupUI();
            updateGarbageMeter();

            // Hide all overlays
            document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));

            fillQueue();
            spawnPiece();
            draw();
            drawQueue();
            drawHold();

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameOver = true;
            gameStarted = false;
            if (timerInterval) clearInterval(timerInterval);
            playGameOver();

            document.getElementById('final-score').textContent = score.toLocaleString();

            let msg = '';
            if (gameMode === 'marathon' && score > (highScores.marathon || 0)) {
                highScores.marathon = score;
                saveHighScores();
                msg = 'NEW HIGH SCORE!';
            }
            document.getElementById('high-score-msg').textContent = msg;
            document.getElementById('gameover-overlay').classList.remove('hidden');
        }

        function completeGame() {
            gameOver = true;
            gameStarted = false;
            if (timerInterval) clearInterval(timerInterval);

            const title = document.getElementById('complete-title');
            const scoreEl = document.getElementById('complete-score');
            const msgEl = document.getElementById('complete-msg');

            if (gameMode === 'sprint') {
                title.textContent = 'SPRINT COMPLETE!';
                scoreEl.textContent = `Time: ${formatTime(timerValue)}`;
                if (timerValue < (highScores.sprint || Infinity)) {
                    highScores.sprint = timerValue;
                    saveHighScores();
                    msgEl.textContent = 'NEW RECORD!';
                } else {
                    msgEl.textContent = `Best: ${formatTime(highScores.sprint)}`;
                }
            } else if (gameMode === 'ultra') {
                title.textContent = 'TIME UP!';
                scoreEl.textContent = `Score: ${score.toLocaleString()}`;
                if (score > (highScores.ultra || 0)) {
                    highScores.ultra = score;
                    saveHighScores();
                    msgEl.textContent = 'NEW HIGH SCORE!';
                } else {
                    msgEl.textContent = `Best: ${highScores.ultra.toLocaleString()}`;
                }
            }

            document.getElementById('complete-overlay').classList.remove('hidden');
        }

        function formatTime(s) {
            return `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
        }

        function togglePause() {
            if (gameOver || !gameStarted) return;
            paused = !paused;

            if (paused) {
                if (timerInterval) clearInterval(timerInterval);
                document.getElementById('pause-overlay').classList.remove('hidden');
            } else {
                if (gameMode === 'sprint' || gameMode === 'ultra') {
                    timerInterval = setInterval(updateTimer, 1000);
                }
                document.getElementById('pause-overlay').classList.add('hidden');
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        function showMenu() {
            gameStarted = false;
            gameOver = false;
            document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
            document.getElementById('start-overlay').classList.remove('hidden');
        }

        // ============== THEME ==============
        function setTheme(name) {
            currentTheme = name;
            document.body.className = `theme-${name}`;
            const t = THEMES[name];
            document.documentElement.style.setProperty('--accent-color', t.accent);
            document.documentElement.style.setProperty('--accent-light', t.light);
            document.documentElement.style.setProperty('--glow-color', t.glow);

            document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.theme-btn.${name}`)?.classList.add('active');
        }

        // ============== HIGH SCORES ==============
        function loadHighScores() {
            try {
                const saved = localStorage.getItem('tetris7_scores');
                if (saved) highScores = { ...highScores, ...JSON.parse(saved) };
            } catch (e) {}
        }

        function saveHighScores() {
            try {
                localStorage.setItem('tetris7_scores', JSON.stringify(highScores));
            } catch (e) {}
        }

        // ============== INPUT ==============
        const keys = {};

        document.addEventListener('keydown', e => {
            if (keys[e.code]) return;
            keys[e.code] = true;

            if (!gameStarted) return;

            if (e.code === 'KeyP' || e.code === 'Escape') {
                togglePause();
                return;
            }

            if (paused || gameOver) return;

            switch (e.code) {
                case 'ArrowLeft':
                    e.preventDefault();
                    move(-1, 0);
                    dasDir = -1;
                    dasTimer = 0;
                    dasActive = false;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    move(1, 0);
                    dasDir = 1;
                    dasTimer = 0;
                    dasActive = false;
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    softDrop();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    rotate(true);
                    break;
                case 'KeyZ':
                    rotate(false);
                    break;
                case 'Space':
                    e.preventDefault();
                    hardDrop();
                    break;
                case 'KeyE':
                case 'KeyC':
                case 'ShiftLeft':
                    hold();
                    break;
                case 'Digit1': usePowerup('bomb'); break;
                case 'Digit2': usePowerup('slow'); break;
                case 'Digit3': usePowerup('clear'); break;
                case 'Digit4': usePowerup('ghost'); break;
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.code] = false;
            if (e.code === 'ArrowLeft' && dasDir === -1) dasDir = 0;
            if (e.code === 'ArrowRight' && dasDir === 1) dasDir = 0;
        });

        // ============== BUTTON HANDLERS ==============
        document.getElementById('mode-marathon').onclick = () => startGame('marathon');
        document.getElementById('mode-sprint').onclick = () => startGame('sprint');
        document.getElementById('mode-ultra').onclick = () => startGame('ultra');
        document.getElementById('mode-zen').onclick = () => startGame('zen');
        document.getElementById('mode-battle').onclick = () => startGame('battle');
        document.getElementById('mode-puzzle').onclick = () => startGame('marathon'); // Simplified

        document.getElementById('restart-btn').onclick = () => startGame(gameMode);
        document.getElementById('menu-btn').onclick = showMenu;
        document.getElementById('complete-restart-btn').onclick = () => startGame(gameMode);
        document.getElementById('complete-menu-btn').onclick = showMenu;
        document.getElementById('resume-btn').onclick = togglePause;

        document.getElementById('sound-btn').onclick = () => {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-btn').textContent = soundEnabled ? 'üîä Sound' : 'üîá Sound';
            if (soundEnabled) initAudio();
        };

        document.getElementById('music-btn').onclick = () => {
            musicEnabled = !musicEnabled;
            document.getElementById('music-btn').textContent = musicEnabled ? 'üéµ Music' : 'üéµ Off';
            if (musicEnabled) { initAudio(); startMusic(); }
        };

        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.onclick = () => setTheme(btn.dataset.theme);
        });

        // Power-up clicks
        document.getElementById('pow-bomb').onclick = () => usePowerup('bomb');
        document.getElementById('pow-slow').onclick = () => usePowerup('slow');
        document.getElementById('pow-clear').onclick = () => usePowerup('clear');
        document.getElementById('pow-ghost').onclick = () => usePowerup('ghost');

        // Touch controls
        document.getElementById('touch-left').ontouchstart = e => { e.preventDefault(); move(-1, 0); };
        document.getElementById('touch-right').ontouchstart = e => { e.preventDefault(); move(1, 0); };
        document.getElementById('touch-down').ontouchstart = e => { e.preventDefault(); softDrop(); };
        document.getElementById('touch-cw').ontouchstart = e => { e.preventDefault(); rotate(true); };
        document.getElementById('touch-ccw').ontouchstart = e => { e.preventDefault(); rotate(false); };
        document.getElementById('touch-hold').ontouchstart = e => { e.preventDefault(); hold(); };
        document.getElementById('touch-drop').ontouchstart = e => { e.preventDefault(); hardDrop(); };

        // ============== INIT ==============
        loadHighScores();
        setTheme('neon');
        draw();
        drawQueue();
        drawHold();
    </script>
</body>
</html>
